*-------------------------------------------------------------------------
*
*  FILE:    WDS1.157.CRUNCH1
*
*  NAME:    CRUNCH A INPUT LINE
*
*  VERSION: 3.0 - 10/15/86    BASE LINE
*
*
* 6.5.2022, Type "GOSUB 173" and crunch will add RETURN (>88) after line #
;           Possibly in PUTCHR for extended codes. >AD representes "173"
;
;
*-------------------------------------------------------------------------
CRNMD  DATA 0                 CRUNCH MODE
EXTTOK DATA 0

QUOTE  EQU  >22
COMMA  EQU  >2C
DOLAR  EQU  >24
DOT    EQU  >2E
COLON  EQU  >3A

BR8LB  EQU  UREG2+17

*    NAME:  CRUNCH
*
*    WHAT:  CRUNCH INPUT INTO BASIC PROGRAM
*
* COMMENT:  R3 CONTAINS THE CRUNCH MODE SELECTED
*

CRUNCH MOV  R3,@CRNMD         SAVE CRUNCH MODE
       CLR  @ERRCOD
       LWPI UREG2             LOAD ALTERNATE REGISTER SET
       LI   R4,BR8LB          SET UP W/S LOW BYTE POINTER
       CLR  R8                INITIALIZE CHARACTER BUFFER
       BL   @GETNB            SCAN LINE FOR FIRST GOOD CHAR
       MOVB R1,*R4            SAVE THE CHARACTER
       JEQ  CRU28             IF EMPTY LINE RETURN

*    NOW CHECK CRUNCH CALL MODE
*    NORMAL OR INPUT

       MOV  @CRNMD,R3             NORMAL CRUNCH CALL
       JEQ  CRU01             YES CRUNCH THE STATEMENT
*
*    INITIALIZE FOR INPUT STATEMENT
*
       LI   R2,CRU84          NO MUST BE CRUNCH OF INPUT STATEMENT
       LI   R10,CRU83         SO SET UP MODE INDICATORS
       LI   R7,CRU80
       JMP  CRU10             AND JUMP INTO IT

*    INITIALIZE FOR NORMAL LINE CRUNCH

CRU01  INC  @BUFLEV           INDICATE CRNBUF IS DESTROYED
       CLR  @ARG+4            ASSUME NOT A SYMBOL
       SZCB @PBIT,@PFLAG      RESET THE PROGRAM FLAG
       BL   @GETINT           TRY TO READ A LINE NUMBER
       MOV  R0,R0             GOT A NUMBER
       JEQ  CRU02             NO
       MOV  R0,@FAC+SNUM      YES - PUT LINE NUMBER IN FAC
       BL   @GETNB            SKIP ALL LEADING SPACES
       MOVB R1,*R4            SAVE THE CHARACTER
       JEQ  CRU28             IF NOTHING LEFT ON LINE
CRU02  LI   R7,CRU16          SET NORMAL SCAN MODE
       LI   R6,CRU96          SET NORMAL NUMERIC SCAN MODE
       JMP  CRU10             MERGE INTO NORMAL SCAN CODE
*
*    MAIN LOOP OF THE INPUT COPY ROUTINE. SETS R8LB TO
*    NEXT CHARACTER. R0 TO ITS CHARACTER PROPERTY BYTE
*    R7 INDICATES DISPATCH MODE
*
CRU04  LI   R6,CRU96          SET NORMAL NUMERIC MODE
CRU05  LI   R7,CRU16          SET NORMAL SCAN MODE
CRU06  BL   @PUTCHR           COPY INTO CRUNCH BUFFER
CRU08  BL   @GETCHR           GET NEXT INPUT CHARACTER
       CLR  R0                ASSUME NIL PROPERTY
       MOVB R1,*R4            COPY TO CRUNCH BUFFER
       JEQ  CRU12             FINISH UP IF WE REACH A NULL
CRU10  MOVB @CPTBL(R8),R0     FETCH CHAR'S PROPERTY
CRU12  B    *R7               DISPATCH TO APPROPIATE CODE
CRU14  MOV  R8,R8             END OF LINE
       JNE  CRU06             NOT YET
CRU15  MOV  @RAMPTR,R3        NOW CHECK FOR TRAILING SPACES
       DEC  R3                BACKUP TO READ LAST CHAR
       BL   @GETLST           GET THE CHARACTER
       CB   R1,@CBH20         LAST CHARACTER A SPACE
       JNE  CRU28             NO, SO END OF LINE AND EXIT
       DEC  @RAMPTR           BACK UP POINTER TO DELETE
       JMP  CRU15             AND TEST NEW LAST CHARACTER
*
*    NORMAL SCAN MODE FIGURES OUT WHAT
*    TO DO WITH THIS CHARACTER
*
CRU16  MOVB *R4,*R4           AT END OF LINE
       JEQ  CRU28             YES - CLEAN UP AND RETURN
       MOVB R0,R0             SET CONDITION ON CHAR PROPERTY VALUE
       JLT  CRU08             IGNORE SEPARATORS
       MOV  @RAMPTR,R9        SAVE CRUNCH POINTER
       SLA  R0,2              SACN PROPERTY BITS 1 AND 2
       JOC  CRU32             BREAK CHARS ARE ONE CHAR TOKENS
       JLT  CRU18             ALPHA PREPARE TO PACK NAME
       SLA  R0,2              SCAN PROPERT BITS 3 AND 4
       JNC  CRU20             JUMP IF NOT MULTI-CHAR OPER
       BL   @GETCHR           CHECK NEXT CHARACTER TO SEE IF WE
       SRL  R1,8              HAVE A TWO-CHAR OPERATOR
       JEQ  CRU32             IF READ END OF LINE A SINGLE-OP
       BL   @BACKUP           BACK-UP READ POINTER
*
*    NEXT CHAR ALSO A MULTI-OP
*
       CB   @CPTBL(R1),@LBCPMO
       JNE  CRU32             NO MUST WANT SINGLE CHAR-OP
       BL   @PUTCHR           COPY IN FIRST CHARACTER OF OPERATOR
       JMP  CRU36             AND SCAN KEYWORD TABLE
*
*    SET NAME COPY MODE
*
CRU18  LI   R7,CRU76          ALPHABETIC SET NAME COPY MODE
       JMP  CRU06             AND RESUME COPY
*
*    HANDLE SINGLE CHARACTER OOPERATORS
*
CRU20  JLT  CRU32             BIT 4 SINGLE CHAR-OPER
       SLA  R0,2              SCAN PROPERTY BITS 5 AND 6
       JOC  CRU24             IF NUMBERIC
       JLT  CRU26             IF DIGIT ONLY
       CI   R8,QUOTE          IS IT A STRING QUOTE
       JNE  CRU26A            NO UNKNOWN CHAR SO ERROR
       MOV  R7,R10            YES SAVE CURRENT MODE
CRU22  LI   R8,STRIN$         CONVERT CHAR TO QUOTE
       BL   @PUTCHR           PUT IN TOKEN
       LI   R7,CRU68          SET STRING COPY MODE
       MOV  @RAMPTR,R5        SAVE POINTER TO LENGTH BYTE
       JMP  CRU06             CONTINUE COPY WITH QUOTE
CRU24  CI   R8,DOT            A DECIMAL POINT
       JNE  CRU26             NO DECODE AS NUMERIC LINE #
       LI   R6,CRU96          YES DECODE AS NUMERIC
CRU26  B    *R6               HANDLE NUMERIC OR LINE #
CRU26A B    @CRUIVN
BERRSY B    @CRUSYN           LONG DISTANCE SYNTAX ERROR
CRU27  BL   @PUTCHR           PUT OUT LAST CHAR BEFORE END
       INC  @BBUFP            SKIP LAST CHAR
*
*    SUCCESSFUL COMPLETION OF SCAN
*
CRU28  CLR  R8                MARK END OF LINE WITH NULL
       BL   @PUTCHR           PUT THE END OF LINE IN
CRNADD EQU  $+2
       LI   R0,CRNBUF         GET START OF CRUNCH BUFFER
       NEG  R0                NEGATE FOR BACKWARDS ADD
       A    @RAMPTR,R0        CALCULATE LINE LENGTH
       MOV  R0,@BUF3L         WRITE THE LENGTH
       LWPI UREG1             LOAD OTHER REGISTER SET
       RT                     AND RETURN

*
*    KEYWORD TABLE SCANNING ROUTINE. NAME HAS ALREADY BEEN
*    COPIED INTO CRUNCH AREA STARTING AT R9. RAMPTR POINTS
*    JUST BEYOND NAME IN INPUT LINE.
*    R3 IS NAME LENGTH. R1 INDEXEX INTO THE TABLE.
*
CRU32  BL   @BACKUP           BACK UP CHARACTER
CRU36  BL   @GETCHR           GET THE NEXT CHARACTER
       MOVB R1,*R4
       BL   @PUTCHR
CRU38  MOV  @RAMPTR,R3
       S    R9,R3
       CI   R3,MAXKEY         IS IT LONGER THAN ANY KEYWORD
       JH   BCRU61            YES CANT BE KEYWORD

       LI   R14,PROA$         DESTINATION ADDRESS IS FAC
       MOV  R3,R2             GET TEH STRING LENGTH
       MOV  R9,R0             COPY START
XYZ01  CB   *R0,@CBH60        IS IT LOWER CASE
       JH   XYZ02             YES
       MOVB *R0,*R14+         NO COPY IT
XYZ04  INC  R0
       DEC  R2                ONE LESS TO DO
       JNE  XYZ01
       JMP  XYZ03

BCRU61 B    @CRU61

XYZ02  MOVB @CBHA0,*R14       NEGATIVE 60
       AB   *R0,*R14+         CORRECT IT
       JMP  XYZ04             AND CONTINUE

XYZ03  MOV  R3,R2
       DEC  R2                CORRECT FOR ZERO LENGTH
       SLA  R2,1              TURN IT INTO AN INDEX
       AI   R2,KEYTAB         ADD IN ADDRESS OF TABLE
*
*    R2 CONTAINS THE NUMBER OF STRINGS IN THIS TABLE
*
       LI   R0,PROA$          POSSIBLE KEYWORD IS IN FAC
       MOV  *R2,R2            GET THE TABLE ADDRESS
       MOV  *R2+,R15          GET THE NUMBER OF ENTRIES
NXTSTR MOV  *R2,R14           GET THE STRING ADDRESS
       INC  R14               GO PASS THE TOKEN VALUE
       MOVB *R14+,R13         GET THE STRING LENGTH
       SRL  R13,8
AGAIN  CB   *R0+,*R14+        COMPARE CHARACTERS
       JNE  FNDNXT            NO MATCH
       DEC  R13               STRING LENGTH
       JEQ  FNDIT             IF LENGTH = ZERO GO IT
       JMP  AGAIN             NO TRY AGAIN

FNDNXT DEC  R15               DECREMENT TABLE ENTRIES
       JEQ  CRU61A            NO MORE LEFT
       INCT R2                INCREMENT TABLE POINTER
       LI   R0,PROA$          RESTORE EDITR STRING POINTER
       JMP  NXTSTR            TRY NEXT STRING

FNDIT  MOV  R9,@RAMPTR        NAME MATCHED SO THROW IT OUT
       MOV  *R2,R14           GET STRING ADDRESS AGAIN
       MOVB *R14+,*R4         READ THE TOKEN VALUE
       MOVB *R14+,R15         GET THE STRING LENGTH
       SRL  R15,8             ALIGN REGISTER
       A    R15,R14           ADD TO POINTER
       MOVB *R14,@EXTTOK      COPY EXTERNTED TOKEN
       CLR  @ARG+4            INDICATES KEYWORD FOUND

*    CHECK FOR SPECIALLY CRUNCHED STATEMENTS

       LI   R7,CRU14          ASSUME A REM STATEMENT
       LI   R0,SPECTB-4       NOW CHECK FOR SPECIAL CASES
       JMP  CRU47
*      CI   R8,MERGE$         IS THIS A COMMAND
*      JH   CRU47             NO CONTINUE ON
*      MOV  @FAC,R3           YES ATTEMPT TO PUT IN PROGRAM
*      JNE  CRUCIP            YES COMMAND ILLEGAL IN PROGRAM
*      CI   R9,CRNBUF         COMMAND FIRST TOKEN IN LINE
*      JNE  BERRSY            NO SYNTAX ERROR

CRU47  INCT R0                SKIP OFFSET VALUE
       INCT R0
       CB   *R4,*R0           IN SPECIAL TABLE
       JEQ  CRU53A            YES HANDLE IT
       JH   CRU47             IF STILL POSSIBLE MATCH

*      CI   R8,MERGE$         A SPECIALLY SCANNED COMMAND
*      JL   CRU27

       LI   R0,LNTAB          NOW CHECK FOR A LINE NUMBER
CRU48  CB   *R4,*R0+          IN TABLE
       JEQ  CRU52             YES CHANGE TO LINE # CRUNCH
       JH   CRU48             MAY STILL BE IN TABLE
       CI   R8,COMMA$         JUST CRUNCH A COMMA
       JEQ  CRU50             YES SO RETURN CURRENT NUMERIC
       CI   R8,TO$            JUST CRUNCHED A TO
       JNE  CRU53             NO-SO RESET TO NORMAL NUMERIC
CRU50  B    @CRU05            YES RESUME NORMAL COPY
CRU52  LI   R6,CRU100         SET LINE NUMBER SCAN MODE
       JMP  CRU50             SET NORMAL SCAN MODE

CRUIVN INC  @ERRCOD           ILLEGAL VARIABLE NAME
CRUCIP INC  @ERRCOD           COMMAND ILLEGAL IN PROGRAM
CRUNQT INC  @ERRCOD           NON-TERMINATED QUOTED STRING
CRUNTL A    @CW04,@ERRCOD     NAME TOO LONG
       B    @CRU28            EXIT BACK TO EXEC
*
*
CRU53  B    @CRU04            STMT SEP RESETS TO NORMAL SCAN
*
*    SOME DATA VARIABLES
*
CBH20  BYTE >20
CBH60  BYTE >60
CBHA0  BYTE ->20
*
*    GOT A MATCH FROM SPECIAL TABLE
*
CRU53A INCT R0                PICK UP OFFSET FROM TABLE
       MOV  *R0,R1            MAKE IT INTO OFFSET
       B    *R1               GOTO SPECIAL CASE HANDLER
*
*    PROCESS A LIST STATEMENT
*
CRU57  BL   @PUTCHR           PUT THE LIST TOKEN IN
       BL   @GETNB            GET THE NEXT CHARACTER
       CI   R1,QUOTE*256      DEVICE NAME AVAILABLE
       JNE  CRU57A            NO NO MORE TO CRUNCH, EXIT
       LI   R10,CRU106        YES SET AFTER STRING SCAN MODE
       B    @CRU22            CRUNCH THE DEVICE NAME
CRU57A B    @CRU28
*
*    PROCESS AN IMAGE STATEMENT
*
CRU54  LI   R10,CRU83B        IMAGE AFTER STRING COPY MODE
       JMP  CRU59             HANDLE SIMILAR TO DATA STMT
*
*    PROCESS A DATA STATEMENT
*
CRU58  LI   R10,CRU83         AFTER DATUM SKIP SPACES
CRU59  C    @RAMPTR,@CRNADD   IMAGE ADN DATA MUST BE FIRST ON LINE
       JNE  JNESY1            IF NOT AN ERROR
       LI   R2,CRU84          NON-QUOTE STRING COPY MODE
CRU60  LI   R7,CRU80          NOW SET CHECK FOR QUOTE MODE
CRU74  B    @CRU06            AND COPY IN STATEMENT TOKEN
*
*    HERE IS WHEN WE DONT FIND SOMETHING
*    IN THE KEYWORD TABLE
*
CRU61  CI   R3,MAXSTR         IS IT LONGER THAN STRING CAN BE
       JH   CRU83D            YES NAME TOO LONG

CRU61A CLR  @EXTTOK           CLEAR EXTENDED TOKEN
       MOV  @ARG+4,R0         SYMBOL NAME LAST TIME TOO
       JNE  JNESY1            YES, CAN'T HAVE TWO IN A ROW
       DEC  @ARG+4            INDICATE SYMBOL NOW
CRU62  LI   R7,CRU16          NO KEYWORD, LEAVE IN CRNBUF
       LI   R6,CRU96          ASSUME NORMAL NUMERIC SCAN
CRU64  B    @CRU08            AND CONTINUE TO SCAN THE LINE
*
*    PROCESS A SUB STATEMENT
*
CRU65  MOV  @RAMPTR,R3        GET THE CURRENT CRUNCH PTR
       DEC  R3                POINT AT LAST CHAR PUT IN
       CB   *R3,@GO$TOK       WAS IT A GO
       JEQ  CRU52             YES SUB IS PART OF GOSUB
*
*    PROCESS A CALL OR SUB STATEMENT
*
CRU66  LI   R7,CRU93          SET NAME COPY
       JMP  CRU74             AND GET NEXT CHAR
CRU32L B    @CRU32
*
*    NOW THE VARIOUS MODE COPY ROUTINES
*    STRING, NAMES, IMAGE, DATA
*
* STRINGS
*
CRU68  MOV  R8,R8             PREMATURE END OF LINE
       JEQ  CRU83E            YES NONTERMINATED STRING
       CI   R8,QUOTE          REACH THE END OF A STRING
       JNE  CRU74             NO CONTINUE COPYING
       BL   @GETCHR           GET NEXT CHAR
       MOVB R1,R1             READ END OF LINE
       JEQ  CRU70             YES CANT BE DOUBLE QUOTE
       CI   R1,QUOTE*256      IS IT TWO QUOTES IN A ROW
       JEQ  CRU74             YES COPY IN A NORMAL QUOTE
       BL   @BACKUP           NO BACKUP AND RTN TO NORMAL SCAN
CRU70  MOV  R10,R7            NEEDED FOR IMAGE/DATA STMTS
CRU72  BL   @LENGTH           CALCULATE LENGTH OF STRING
       JMP  CRU64             RESUME SCAN
*
*    NAMES
*
CRU76  ANDI R0,CPALNM*256     IS THIS CHAR ALPHA OR DIGIT
       JNE  CRU74             YES CONTINUE PACKING
       CI   R8,DOLAR          DOES NAME END WITH A $
       JEQ  CRU32L            YES INCLUDE IT IN NAME
       MOVB *R4,*R4           AT THE END OF LHE LINE
       JEQ  CRU79             YES DONT BACK UP POINTER
       BL   @BACKUP           BACKUP FOR NEXT CHAR
CRU79  B    @CRU38            JUMP TO NAME/KEYWORD CHECK
CRU82  B    @CRU22
*
*    DATA SCAN SPACES AFTER A QUOTED STRING
*
CRU83  CI   R8,COMMA          HIT A COMMA ?
       JEQ  CRU85A            YES - GET BACK INTO SCAN
*
*    IMAGE: SCAN SPACES AFTER A QUTOTED STRING
*
CRU83B MOVB R0,R0             AT A SPACE ?
       JLT  CRU64             YES - IGNORE IT
       MOV  R8,R8             AT END OF LINE
       JEQ  CRU62             YES - EXIT SCAN
JNESY1 B    @CRUSYN            UN-KNOWN CHARACTER
CRU83D B    @CRUNTL
CRU83E B    @CRUNQT
*
*    DATA: SCAN IMBEDDED BLANKS AND CHECK TRAILING BLANKS
*
CRU83A MOV  @BBUFP,@ARG+2    SAVE IPNUT POINTER
       BL   @GETNB            LOOK FOR NEXT NON-BLANK
       MOVB R1,R1             AT THE END OF THE LINE ?
       JEQ  CRU92             YES-END STRING AND EXIT
       CI   R10,CRU83B        SCANNING AN IMAGE
       JEQ  CRU83C            YES-COMMAS ARE NOT SIGNIFICANT
       CI   R1,COMMA*256      HIT A COMMA ?
       JEQ  CRU85             YES - IGNORE TRAILING SPACES
CRU83C MOV  @ARG+2,@BBUFP      NO - RESTORE INPUT POINTER
       JMP  CRU74             AND INCLUDE IMBEDDED SPACE
*
*    DATA: SCAN UNQOTED STRINGS
*
CRU84  JLT  CRU83A            IF HIT A SPACE-END OF STRING
       MOV  R8,R8             AT THE END OF THE LINE
       JEQ  CRU92             YES - PUT IN LENGTH AND EXIT
       CI   R8,COMMA          REACHED A COMMA
       JNE  CRU74             NO - SCAN UNQUOTED STRING
       CI   R10,CRU83B        SCANNING AN IMAGE STATEMENT
       JEQ  CRU74             COMMAS ARE NOT SIGNIFICANT
CRU85  BL   @LENGTH           YES- END THE STRING
CRU85A LI   R8,COMMA$         LOAD A COMMA TOKEN
       INC  @VAR5             COUNT COMMA FOR INPUT STATEMENT
       JMP  CRU60             AND RESUME IN STRING MODE
*
*    IMAGE/DATA: CHECK FOR LEADING QUOTE MARK
*
CRU80  JLT  CRU64             IGNORE LEADING SEPARATORS
       CI   R8,QUOTE          QUOTED STRING ?
       JEQ  CRU82             YES - LIKE ANY STRING R10 OK
       MOV  R8,R8             END OF THE LINE
       JEQ  BCRU28            YES END IT
       CI   R10,CRU83B        SCANNING AN IMAGE
       JEQ  CRU88             YES IGNORE COMMAS
       CI   R8,COMMA          AT A COMMA
       JEQ  CRU85A            YES PUT IT IN DIRECTLY
CRU88  MOV  R2,R7             NO - SET UNQUOTE STR AND COPY
*
*    IMAGE & DATA: UNQUOTED STRINGS
*
CRU86  LI   R8,UNQST$         LOAD UNQUOTED STRING TOKEN
       BL   @PUTCHR           PUT THE TOKEN IN
       MOV  @RAMPTR,R5        SAVE CURRENT CRUNCH POINTER
       BL   @BACKUP           BACK UP TO SCAN AGAIN
CRU87  B    @CRU74             RESUME SCAN
*
*    CALL AND SUB STATEMENTS
*
CRU94  ANDI R0,CPALNM*256     STILL AN ALPHA-NUMERIC
       JNE  CRU87             YES-INCLUDE IN NAME
       MOV  R8,R8             AT THE END OF THE LINE ?
       JEQ  CRU92             YES GET OUT NOW
CRU90  BL   @BACKUP           YES-RESET READ POINTER
CRU92  LI   R7,CRU16          NORMAL SCANNING MODE
       JMP  CRU72             CALCULATE AND PUT IN STRING
CRU92A B    @CRUSYN
*
*    CALL AND SUB STATEMENTS BEFORE NAME
*
CRU93  JLT  BCRU64             IF SPACE IGNORE IT
       MOV  R0,R0             PREMATURE EOL OR NIL CHAR PROP
       JEQ  CRU92A            YES - SYNTAX ERROR
       ANDI R0,CPALPH*256     AN ALPHABETIC TO START
       JEQ  CRU92A            YES SYNTAX ERROR
       LI   R7,CRU94          SET UP TO COPY NAME
       JMP  CRU86             PUT IN UNQST TOKEN

BCRU64 B    @CRU64
*
*    NUMERICS
*
CRU96  LI   R7,CRU98          SET AFTER INITIALIZE SCAN
       CLR  @ARG              CLEAR THE 'E' FLAG
       JMP  CRU86             SET UP FOR THE NUMERIC
CRU98  MOV  R8,R8             AT THE END OF THE LINE
       JEQ  CRU92             YES END THE NUMBER
       SLA  R0,2              SCAN PROPERTY BIT 2
       JLT  CRU99A            IF ALPHA MIGHT BE 'E'
       SLA  R0,3              SCAN PROPERTY BITS 4 AND 5
       JNC  CRU99             BIT4=OPER IF NOT OPER JMP
       MOV  @ARG,R0           IF OPERATOR FOLLOW AN 'E'
CRU99  CLR  @ARG              PREVIOUS CHAR NO LONGER AN 'E'
       JLT  CRU87             IF STILL NUMERIC
       JMP  CRU90             NO LONGER NUMERIC
CRU99A CI   R8,'E'            'E' TO INDICATE AN EXPONENT
       JNE  CRU90             NO SO END THE NUMERIC
       MOV  @ARG,R0           AN 'E' ALREADY ENCOUNTERED
       JNE  CRU92A            YES - SO ERROR
       SETO @ARG              NO INDICATE 1 ENCOUNTERED NOW
       JMP  CRU87             AND INCLUDE IT IN THE NUMBER
*
*    LINE NUMBERS
*
CRU100 MOV  R8,R8             AT THE END OF THE LINE
       JEQ  BCRU28            YES - EXIT CRUNCH
       BL   @GETINT           TRY TO GET A LINE NUMBER
       MOV  R0,R0             GET A LINE NUMBER
       JEQ  CRU105            NO - BACK TO NORMAL NUMERIC MODE
       LI   R8,LN$            LOAD A LINE NUMBER TOKEN

; fixes w/putchr2        3.10.2023
       BL   @PUTCHR           PUT IT OUT
       MOV  R0,R8             SET UP TO PUT OUT BINARY NUM
       SWPB R8                SWAP TO PUT OUT MSB
       BL   @PUTCHR2          PUT OUT FIRST BYTE
       SETO @PUTCHRFIX   ;FOR 2nd half of line number, via CRU06
;
       SRL  R8,8              BARE THE SECOND
       JMP  CRU87             JMP BACK INTO IT
CRU105 B    @CRU04

*
*    HANDLE A LIST STATEMENT
*

CRU106 JLT  CRU93             IF SPACE IGNORE IT
       MOV  R8,R8             AT THE END OF THE LINE
       JEQ  BCRU28            YES - EXIT CRUNCH
       CI   R8,COLON          GET A COLON
       JNE  CRUSYN            NO SYNTAX ERROR
       LI   R8,COLON$         NEED TO PUT COLON IN
       B    @CRU27            AND EXIT CRUNCH

*
*    ERROR HANDLING ROUTINES
*

CRULTL INC  @ERRCOD           3 - LINE TOO LONG
       DECT @RAMPTR
CRUBLN INC  @ERRCOD           2 - BAD LINE NUMBER
CRUSYN INC  @ERRCOD           1 - SYNTAX ERROR
BCRU28 B    @CRU28

       PAGE
*
*    GET THE LAST CHARACTER
*
*

GETLST CLR  R1
       MOVB @EDITB+1(R3),R1     GET THE CHARACTER
       RT

*
*      WRITTEN: 06/14/1985
*
*      NAME:    BACK UP POINTER
*

BACKUP DEC  @BBUFP            BACK UP POINTER
       MOV  @BBUFP,R0
       AI   R0,EDITB+1
       MOVB *R0,R0
       RT

       PAGE
*
*      WRITTEN: 06/14/1985
*
*      NAME:    PUTCHR
*
PUTCHRFIX DATA >0000     ;0=NORMAL; 1=LINE# OPERATION

PUTCHR2 SETO @PUTCHRFIX       3.10.2023

PUTCHR MOV  @RAMPTR,R1        GET THE ADDRESS
       CI   R1,CRNEND         AT THE END OF THE BUFFER
       JH   CRULTL            ERROR LINE TOO LONG
       MOVB *R4,*R1           COPY THE TOKEN
       INC  @RAMPTR           UPDATE RAM POINTER
       ABS  @PUTCHRFIX        ;3.10.2023  normal scan?
       JNE  PUT1RX            ;3.10.2023  no. Skip to fix line # intercept

       CB   *R4,@CBHE3        GOT EXTENDED FUNCTION
       JEQ  PUT10             JUMP IF YES
;
;6.4.22, removed for TEST purposes. CINT?
;3.10.2023, restored for normal operation until we figure it out.
;
       CB   *R4,@CBHAD        GOT EXTENDED NUD
       JEQ  PUT10             JUMP IF YES
;;----end of test area for crunch test

       JMP  PUT1RX            ;3.10.2023, CAN INVERT JUMP LATER
;;     RT                     NO RETURN      ;3.10.2023

PUT10  INC  R1                INC POINTER
       MOVB @EXTTOK,*R1       WRITE THE TOKEN
       INC  @RAMPTR           INC PERM POINTER
PUT1RX CLR  @PUTCHRFIX        ;3.10.2023, enforce normal scan mode
       RT                     AND RETURN

*
*      WRITTEN: 06/14/1985
*
*      NAME:    CALCULATE AND PUT LENGTH OF STRING/NUMBER
*               INTO LENGTH BYTE
*

LENGTH MOV  R11,R3            SAVE RETURN
       MOV  @RAMPTR,R0        SAVE CURRENT CRUNCH POINTER
       MOV  R0,R8
       S    R5,R8             CALCULATE LENGTH OF STRING
       DEC  R8                RAM POINTER IS POST INCREMENTED
       MOV  R5,@RAMPTR        ADDRESS OF LENGTH BYTE
       BL   @PUTCHR           PUT THE LENGTH IN
       MOV  R0,@RAMPTR        RESTORE CRUNCH POINTER
       B    *R3               RETURN

       PAGE
*
*      NAME:    GET A SMALL NON-NEGATIVE INTEGER
*
*      ENTRY:   BBUFP = TEXT POINTER
*

GETINT MOV  R11,R3            SAVE RETURN ADDRESS
       MOV  R8,R0             GET POSSIBLE DIGIT
       LI   R2,10             GET RADIX IN REG FOR SPEED
       AI   R0,-'0'           CONVERT FROM ASCII
       C    R0,R2             IS THE CHAR A DIGIT
       JL   GETI02            YES THERE IS A NUMBER
       CLR  R0                NO INDICATE NO NUMBER
       B    *R3               DONE RETURN
GETI01 MPY  R2,R0             MULTIPLY PREVIOUS BY RADIX
       MOV  R0,R0             OFERFLOW
       JNE  CRUBLN            YES BAD LINE NUMBER
       MOV  R1,R0             GET LOW ORDER WORD OF PRODUCT
       A    R8,R0             ADD IN NEXT DIGIT
       JLT  CRUBLN            IF NUMBER WENT NEGATIVE
GETI02 BL   @GETCHR           GET NEXT CHARACTER
       MOVB R1,*R4            PUT INTO NORMAL POSITION
       JEQ  GETI03            IF READ END OF LINE
       AI   R8,-'0'           CONVERT FROM ASCII
       C    R8,R2             IS THIS CHAR A DIGIT
       JL   GETI01            YES TRY TO PACK IT IN
       DEC  @BBUFP            NO POINT TO FIRST CHAR AFTER NUM
GETI03 CLR  R8                CLEAN UP OUR MESS
       MOV  R0,R0             HIT A NATURAL ZERO
       JEQ  CRUBLN            YES ITS AN ERROR
       B    *R3               AND RETURN
*
*    THE LINE NUMBER TABLE
*    ALL TOKENS WHICH APPEAR IN THE TABLE MUST HAVE
*    NUMERICS WHICH FOLLOW THEM CRUNCHED AS A LINE
*    NUMBER
*
LNTAB  BYTE ELSE$
GO$TOK BYTE GO$
       BYTE GOTO$,GOSUB$,RETUR$
       BYTE BREAK$,UNBRK$,RESTO$,ERROR$,RUN$
       BYTE THEN$,USING$,>FF
*
*    TABLE OF SPECIALLY CRUNCHED STATEMENTS
*    BYTE   TOKEN VALUE
*    DATA   ADDRESS OF SPECIAL HANDLER
*
       EVEN
*SPECTB BYTE LIST$,0
*       DATA CRU57
*
*       BYTE OLD$,0
*       DATA CRU58
*
*       BYTE SAVE$,0
*       DATA CRU58
*
*       BYTE MERGE$,0
*       DATA CRU58

SPECTB BYTE SSEP$,0           STATEMENT SEP
       DATA CRU53

       BYTE TREM$,0           TAIL REMARK
       DATA CRU74

       BYTE DATA$,0           DATA
       DATA CRU58

       BYTE REM$,0            REMARK
       DATA CRU74

       BYTE CALL$,0           CALL
       DATA CRU66

       BYTE SUB$,0            SUB
       DATA CRU65

       BYTE IMAGE$,0          IMAGE
       DATA CRU54

       BYTE >FF,0             TABLE END
       DATA 0

       PAGE
*
*
*      WHAT:    GETS THE NEXT BLANK CHARACTER FROM THE INPUT
*               EDIT RECALL BUFFER
*

GETNB  MOV  R11,R14           SAVE RETURN
GETNB1 BL   @GETCHR           GET THE NEXT CHARACTER
       CI   R1,>2000          IS IT A SPACE
       JEQ  GETNB1            YES - GET ANOTHER
       B    *R14              NO RETURN


GETCHR CB   @BBUFP+1,@BBUFL   AT THE END OF A LINE
       JH   GTNB01            YES
       MOV  @BBUFP,R1         NO - GET CURRENT POINTER
       MOVB @EDITB+1(R1),R1   GET CHARACTER
       INC  @BBUFP            ADJUST POINTER
       SWPB R1                FOR THE CLEAR
       SLA  R1,8              ALIGN REGISTER
       RT                     AND RETURN

GTNB01 CLR  R1                INDICATE END
       RT                     AND RETURN

CBHBE  BYTE >BE
PERCT  BYTE >25
BALBAT BYTE >21
POUND  BYTE >23
;eof
